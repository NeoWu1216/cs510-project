<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /mnt/c/Users/pc/Desktop/cs510_proj/grobid-0.5.6/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Memory Efficient Max Flow for Multi-label Submodular MRFs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thalaiyasingam</forename><surname>Ajanthan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Australian National University &amp; NICTA * Canberra</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Hartley</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Australian National University &amp; NICTA * Canberra</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>CVLAB</roleName><forename type="first">Mathieu</forename><surname>Salzmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Australian National University &amp; NICTA * Canberra</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Epfl</forename><surname>Lausanne</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Australian National University &amp; NICTA * Canberra</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Switzerland</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Australian National University &amp; NICTA * Canberra</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Memory Efficient Max Flow for Multi-label Submodular MRFs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.5.6" ident="GROBID" when="2019-12-02T16:43+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-label submodular Markov Random Fields</head> (MRFs)   <p>have been shown to be solvable using max-flow based on an encoding of the labels proposed by Ishikawa, in which each variable X i is represented by ℓ nodes (where ℓ is the number of labels) arranged in a column. However, this method in general requires 2 ℓ 2 edges for each pair of neighbouring variables. This makes it inapplicable to realistic problems with many variables and labels, due to excessive memory requirement. In this paper, we introduce a variant of the max-flow algorithm that requires much less storage. Consequently, our algorithm makes it possible to optimally solve multi-label submodular problems involving large numbers of variables and labels on a standard computer.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Ishikawa <ref type="bibr" target="#b12">[13]</ref> introduced a max-flow-based method to globally minimize the energy of multi-label MRFs with convex edge terms. In <ref type="bibr" target="#b21">[22]</ref>, this method was extended to energy functions satisfying the multi-label submodularity condition, analogous to the submodularity condition for MRFs with binary labels. In the general case, however, this method requires 2 ℓ 2 directed edges for each pair of neighbouring variables. For instance, for a 1000 × 1000, 4connected image with 256 labels, it would require approximately 1000×1000×2×256 2 ×2×4 ≈ 1000 GB of memory to store the edges (assuming 4 bytes per edge). Clearly, this is beyond the storage capacity of most computers.</p><p>In this paper, we introduce a variant of the max-flow algorithm that requires storing only two ℓ-dimensional vectors per variable pair instead of the 2 ℓ 2 edge capacities of the standard max-flow algorithm. In the example discussed above, our algorithm would therefore use only 4 GB of memory for the edges. As a result, our approach lets us optimally solve much larger problems.</p><p>More specifically, in contrast to the usual augmenting path algorithm <ref type="bibr" target="#b7">[8]</ref>, we do not store the residual edge capacities at each iteration. Instead, our algorithm records two ℓ-dimensional flow-related quantities for every pair of neighbouring variables. We show that, at any stage of the algorithm, the residual edge capacities can be computed from these flow-related quantities and the initial edge capacities. This, of course, assumes that the initial capacities can be computed by some memory-efficient routine, which is almost always the case in computer vision.</p><p>The optimality of Ishikawa's formalism made it a method of choice as a subroutine in many approximate energy minimization algorithms, such as multi-label moves <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27]</ref> and IRGC <ref type="bibr" target="#b0">[1]</ref>. Since our approach can simply replace the standard max-flow algorithm <ref type="bibr" target="#b4">[5]</ref> in Ishikawa-type graphs, it also allows us to minimize the energy of much larger non-submodular MRFs in such approximate techniques. Furthermore, due to the similarity to standard max-flow, our algorithm can easily be extended to handle dynamic MRFs <ref type="bibr" target="#b15">[16]</ref> and also be accelerated using the parallel max-flow technique <ref type="bibr" target="#b23">[24]</ref>.</p><p>We demonstrate the effectiveness of our algorithm on the problems of stereo correspondence estimation and image inpainting. Our experimental evaluation shows that our method can solve much larger problems than standard max-flow on a standard computer and is an order of magnitude faster than state-of-the-art message-passing algorithms <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. Our code is available at https: //github.com/tajanthan/memf.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>Let X i be a random variable taking label x i ∈ L. A pairwise MRF defined over a set of such random variables can be represented by an energy of the form</p><formula xml:id="formula_0">E(x) = i∈V θ i (x i ) + (i,j)∈E θ ij (x i , x j ) ,<label>(1)</label></formula><p>where θ i and θ ij denote the unary potentials (i.e., data costs) and pairwise potentials (i.e., interaction costs), respectively. Here, V is the set of vertices, e.g., corresponding to pixels or superpixels in an image, and E is the set of edges in the MRF, e.g., encoding a 4-connected or 8-connected grid over the image pixels.</p><p>In this work, we consider a pairwise MRF with an ordered label set L = {0, 1, · · · , ℓ − 1}, and we assume that the pairwise terms are multi-label submodular <ref type="bibr" target="#b21">[22]</ref>:</p><formula xml:id="formula_1">θ ij (λ ′ , µ) + θ ij (λ, µ ′ ) − θ ij (λ, µ) − θ ij (λ ′ , µ ′ ) ≥ 0 , (2)</formula><p>for all λ, λ ′ , µ, µ ′ ∈ L, where λ &lt; λ ′ and µ &lt; µ ′ . Furthermore, we assume that the pairwise potentials can be computed either by some routine or can be stored in an efficient manner. In other words, we assume that we do not need to store each individual pairwise term. Note that, in computer vision, this comes at virtually no loss of generality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">The Ishikawa graph</head><p>Ishikawa <ref type="bibr" target="#b12">[13]</ref> introduced a method to represent the multi-label energy function (1) in a graph. The basic idea behind the Ishikawa construction is to encode the label X i = x i of a vertex i ∈ V using binary-valued random variables U i:λ , one for each λ ∈ {1, · · · , ℓ − 1}. In particular, the encoding is defined as u i:λ = 1 if and only if x i ≥ λ, and 0 otherwise. The Ishikawa graph is then an st-grapĥ G = (V ∪ {0, 1},Ê), consisting of one node for each U i:λ , along with source and terminal nodes 1 , with edges joining neighbouring nodes, as shown in <ref type="figure" target="#fig_0">Fig. 1</ref>. Note that the nodes U i:ℓ and U i:0 are identified with node 0 and node 1 respectively. We denote the Ishikawa edges by e ij:λµ ∈Ê (contains edges in both directions) and their capacities by φ ij:λµ . We also denote by e i:λ the downward edge U i:λ+1 → U i:λ .</p><p>In an st-graph, a labeling x is represented by a "cut" in the graph (a "cut" partitions the nodes into two disjoint subsetsV 0 andV 1 , with 0 ∈V 0 and 1 ∈V 1 ). Then, the value of the energy function E(x) is equal to the sum of the capacities on the edges fromV 0 toV 1 . In an Ishikawa graph, if the edge e i:λ is in the "cut", then vertex i takes label λ. Since each vertex i takes exactly one label x i , exactly one edge e i:λ must be in the min-cut. This is ensured by having infinite capacity for each upward edge U i:λ → U i:λ+1 in each column i. <ref type="bibr" target="#b0">1</ref> We denote them by 0 and 1, but some authors denote them by s and t.</p><p>Finding the minimum energy labeling is a min-cut problem, which can be solved optimally using max-flow <ref type="bibr" target="#b7">[8]</ref> when the edge capacities are non-negative. As shown in <ref type="bibr" target="#b21">[22]</ref>, a multi-label submodular function can be represented by an Ishikawa graph with non-negative edge capacities and can therefore be minimized optimally by max-flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Max flow</head><p>The most popular max-flow algorithm in computer vision <ref type="bibr" target="#b4">[5]</ref> is an augmenting path algorithm that finds a path from node 0 to node 1 through positive edges (called an augmenting path) and then pushes the maximum flow without exceeding the edge capacities (called augmentation). The augmentation operation changes the edge capacities in the graph, and therefore, the residual graph needs to be stored. That is, when applied to the Ishikawa graph, the max-flow algorithm stores 2 ℓ 2 values per pair of neighbouring variables. For large numbers of labels and of variables, the memory requirement is high and, in many practical problems, exceeds the capacity of most computers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Our idea</head><p>Let us assume that the max-flow algorithm is applied to the Ishikawa graph. As the algorithm proceeds, the capacities on the edges in the graph change in response to the flow. Here, instead of storing the residual graph, we propose recording the flow that has been applied to the graph.</p><p>However, since storing the flow would also require 2 ℓ 2 values per variable pair, we propose recording two ℓdimensional quantities related to the flow between a pair of variables. More precisely, for each directed edge 2 (i, j) ∈ E + , we record the sum of outgoing flows from each node U i:λ to the nodes U j:µ for all µ ∈ {1, · · · , ℓ − 1}. We call this quantity an exit-flow, denoted by Σ ij:λ (defined below in Eq. 4). We show that these exit-flows allow us to reconstruct a permissible flow (defined below in Def. 3.2), which in turn lets us compute the residual edge capacities from the initial ones. Importantly, while flow reconstruction is not unique, we show that all such reconstructions are equivalent up to a null flow (Def. 3.3), which does not affect the energy function. Note that this idea can be applied to any augmenting path algorithm, as long as the residual graph can be rapidly constructed.</p><p>For increased efficiency, we then show how finding an augmenting path can be achieved in a simplified Ishikawa graph that amalgamates the nodes in each column into blocks. We then perform augmentation, which translates to updating our exit-flows, in this simplified graph. As a side effect, since an augmenting path in our simplified graph corresponds to a collection of augmenting paths in the Ishikawa graph, our algorithm converges in fewer iterations than the standard max-flow implementation of <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Memory efficient max flow</head><p>We now introduce our memory efficient max flow algorithm, which minimizes multi-label submodular MRF energies with pairwise interactions. As mentioned in Section 2.3, our algorithm is also an augmenting path algorithm. However, instead of storing the residual graph, we propose storing exit-flows, which, at any stage of the algorithm, would allow us to compute the residual graph. In the remainder of this section, we first show how the cumulative flow can be stored in a memory efficient manner, and then turn to the problem of finding an augmenting path and performing augmentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Memory efficient flow encoding</head><p>Let us assume that the max-flow algorithm is applied to the Ishikawa graph. At some point in the algorithm, flow has passed along many of the edges of the graph.</p><p>Definition 3.1. A flow is a mapping ψ :Ê → IR, denoted by ψ ij:λµ for the edges e ij:λµ , that satisfies the antisymmetry condition ψ ij:λµ = −ψ ji:µλ for all e ij:λµ ∈Ê.</p><p>A flow is called conservative 3 if the total flow into a node is zero for all nodes, except for the source and the terminal, i.e., j,µ|e ji:µλ ∈Ê</p><formula xml:id="formula_2">ψ ji:µλ = 0 ∀ U i:λ ∈V .<label>(3)</label></formula><p>Given ψ, the residual capacities of the Ishikawa graph are updated as φ = φ 0 − ψ, where φ 0 represents the initial edge capacities. Furthermore, we call the flow restricted to each column column-flows, which we denote by ψ i:λ ; i ∈ V, λ ∈ L.</p><p>At first sight, it might seem that, to apply the maxflow algorithm, it is necessary to keep track of all the values ψ ij:λµ , which would require the same order of storage as recording all the edge capacities. Below, however, we show that it is necessary to store only O(ℓ) values for each</p><formula xml:id="formula_3">(i, j) ∈ E, instead of O(ℓ 2 ).</formula><p>To this end, for each (i, j) ∈ E + and λ ∈ {1, · · · , ℓ− 1}, we define an exit-flow as</p><formula xml:id="formula_4">Σ ij:λ = µ ψ ij:λµ .<label>(4)</label></formula><p>We will show that these exit-flows permit the flow ψ to be reconstructed up to equivalence. Now, let us define some additional properties of flow, which will be useful in our exposition.   Note that a null flow does not change the energy function represented by the st-graph and it is identical to passing flow around loops. Also, if ψ is a null flow then so is −ψ.</p><p>Furthermore, note that the energy function encoded by an st-graph is a quadratic pseudo-boolean function <ref type="bibr" target="#b3">[4]</ref>, and a reparametrization of such a function is identical to a null flow in the corresponding st-graph. </p><formula xml:id="formula_5">E φ ≡ E φ ′ , if and only if φ ′ − φ is a null flow.</formula><p>Proof. This lemma is a restatement of the reparametrization lemma of <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b30">31]</ref> in the context of st-graphs.</p><p>Let φ and φ ′ be two sets of residual capacities obtained from an initial set of capacities φ 0 by passing two flows ψ and ψ ′ , i.e., φ = φ 0 − ψ and φ ′ = φ 0 − ψ ′ . If φ and φ ′ are equivalent, then, by Lemma 3.1,</p><formula xml:id="formula_6">(φ 0 − ψ) − (φ 0 − ψ ′ ) = ψ ′ − ψ is a null flow.</formula><p>Hence ψ ′ can be obtained from ψ by passing flow around loops in the graph. See <ref type="figure" target="#fig_2">Fig. 2</ref>.</p><p>We can now state our main theorem.</p><p>Theorem 3.1. Let φ 0 be the initial capacities of an Ishikawa graph, and let Σ be a set of exit-flows. Suppose that ψ and ψ ′ are two flows compatible with Σ, meaning that (4) holds for both ψ and ψ ′ , and that ψ and ψ ′ have identical column-flows. Then</p><formula xml:id="formula_7">E φ 0 −ψ ≡ E φ 0 −ψ ′ .</formula><p>The idea is then as follows. If a permissible conservative flow ψ is obtained during an augmenting path flow algorithm, but only the exit-flows Σ ij:λ are retained for each (i, j) ∈ E + and label λ, then one wishes, when required, to reconstruct the flow ψ on a given edge (i, j) ∈ E. Although the reconstructed flow ψ ′ may not be identical with the flow ψ, the two will result in equivalent energy functions (not just equal up to a constant, but exactly equal for all assignments). In the augmenting path algorithm, the current flow values are only needed temporarily, one edge at a time, to find a new augmenting path, and hence do not need to be stored, as long as they can be rapidly computed. Now we prove Theorem 3.1.</p><formula xml:id="formula_8">Algorithm 1 Flow reconstruction Require: Given a directed edge (i, j) ∈ E + for λ ← ℓ − 1 to 1 do if Σ ij:λ ≥ 0 then for µ ← ℓ − 1 to 1 do if Σ ji:µ ≤ 0 then ψ ′ ij:λµ ← min(|Σ ij:λ |, φ 0 ij:λµ , |Σ ji:µ |) ψ ′ ji:µλ ← −ψ ′ ij:λµ Σ ji:µ ← Σ ji:µ − ψ ′ ji:µλ Σ ij:λ ← Σ ij:λ − ψ ′ ij:λµ if Σ ij:λ = 0 then break</formula><p>Proof. Given a flow ψ, let us denote its restriction to the edges e ij:λµ for all λ, µ ∈ {1, . . . , ℓ−1} for some (i, j) ∈ E by ψ ij , i.e. restriction to cross edges only. Since both ψ ij and ψ ′ ij satisfy Eq. 4, ψ ′ ij − ψ ij is a null flow. Furthermore, since both ψ and ψ ′ have identical column-flows,</p><formula xml:id="formula_9">ψ ′ − ψ = (φ 0 − ψ) − (φ 0 − ψ ′ )</formula><p>is a null flow and, by Lemma 3.1,</p><formula xml:id="formula_10">E φ 0 −ψ ≡ E φ 0 −ψ ′ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Flow reconstruction</head><p>Given the set of exit-flows Σ, the objective of the flow reconstruction problem is to find a permissible flow ψ ′ satisfying Eq. 4. Note that there exists a permissible conservative flow ψ compatible with Σ and hence we find ψ ′ such that ψ ′ − ψ is a null flow. We do this by considering one edge (i, j) ∈ E at a time and reconstruct the flow by formulating a small max-flow problem.</p><p>Considering all the nodes U i:λ and U j:µ for a given pair (i, j), we join them with edges with initial capacities φ 0 ij:λµ . Nodes with positive exit-flow Σ ij:λ are joined to the source with edges of capacities |Σ ij:λ |. Similarly, those with negative exit-flow are joined to the terminal. See <ref type="figure" target="#fig_5">Fig. 3</ref>.</p><p>Note that, in this network, the edges from the source can be thought of as "supply" and the edges to the terminal can be thought of as "demand". Since the total supply equals the total demand in this network and there exists a permissible flow ψ ij compatible with Σ (i.e., satisfying the supply-demand equality), the maximum flow solution of this network ψ ′ ij is compatible with Σ, i.e., satisfies Eq. 4. In fact we are interested in non-negative residual capacities φ ′ ij = φ 0 ij − ψ ′ ij which are readily available in this network. Now one possible max-flow algorithm is to find all the augmenting paths in this network and push maximum permissible flow through them. Note that all minimal length (length 3) augmenting paths can be found by calling Algorithm 1 twice, first for the directed edge i → j and then for j → i. In our experiments such a two-pass procedure has always found a permissible flow ψ ′ ij satisfying Eq. 4. However, in general, this may require finding longer augmenting paths, meaning that one may need to run a max-flow algorithm on this small st-graph. While this graph has O(ℓ) nodes and O(ℓ 2 ) edges, this remains perfectly tractable, since we only consider one edge (i, j) at a time. Therefore, ultimately, flow reconstruction can be done efficiently.</p><p>At this point, given the initial capacities φ 0 and the set of exit-flows Σ, we have shown how to reconstruct the nonnegative residual edge capacities φ ′ . In fact, in addition to the set of exit-flows Σ, we need to store the column-flows ψ i:λ ; i ∈ V, λ ∈ L, to completely reconstruct the residual graph. This requires O((|V| + |E|) ℓ) values to be stored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Efficiently finding an augmenting path</head><p>Our algorithm follows a similar procedure as the usual max-flow, in that it iteratively finds an augmenting path and then pushes the maximum permissible flow through it. By contrast with the usual max-flow, however, we do not store the Ishikawa graph. Instead, we find an augmenting path in a simplified graph, whose construction is detailed below.</p><p>Given the capacities φ, we rely on the fact that there exists a label λ such that φ i:λ = 0 for each i ∈ V. In fact, it is easy to see that in each column i, if all φ i:λ are positive, then there exists a trivial augmenting path from U i:ℓ to U i:0 , and the minimum along the column can be subtracted from each φ i:λ . Now, at each column i, we partition the nodes U i:λ for all λ ∈ {1, · · · , ℓ − 1} into a set of blocks, such that each node in a block is connected with positive edges e i:λ . Let us denote these blocks by B i:γ , where γ is indexed from bottom to top starting from 0. Note that there is no edge between B i:γ and B i:γ±1 . As depicted by <ref type="figure">Fig. 4</ref>, our simplified graph then contains only the blocks and the edges between the blocks.</p><p>The edges between the blocks in the simplified graph are obtained as follows. Let us consider a directed edge (i, j) ∈ E + . We add an edge B i:γ → B j:δ , where δ is the smallest value such that φ ij:λµ is positive for some U i:λ ∈ B i:γ and U j:µ ∈ B j:δ . While doing this, we also enforce that there is no edge B i:γ ′ → B j:δ ′ such that γ ′ &gt; γ and δ ′ &lt; δ. The reasoning behind this is that, because of the upward infinitecapacity edges between the nodes U i:λ and U i:λ+1 , we have the following: <ref type="figure">Figure 4</ref>: To find an augmenting path in a memory efficient manner, we propose a simplified representation of the Ishikawa graph in terms of blocks corresponding to consecutive non-zero edges in each column i.</p><p>1. If a node U j:µ can be reached from U i:λ through positive edges, then the nodes U j:µ ′ , for all µ ′ ≥ µ, can also be reached.</p><p>2. If a node U j:µ can be reached from U i:λ through positive edges, then it can also be reached from the nodes U i:λ ′ , for all λ ′ ≤ λ. Hence, an edge B i:γ → B j:δ indicates the fact that there is some positive flow possible from any node U i:λ ∈ B i:γ ′ , for all γ ′ ≤ γ, to any node U j:µ ∈ B j:δ ′ , for all δ ′ ≥ δ. In other words, the set of edges obtained by this procedure is sufficient. Now, the relationship between augmenting paths in the original Ishikawa graph and in our simplified graph can be characterized by the following theorem. Note that the simplified graph can only be used to find an augmenting path; the quantity of the maximum permissible flow cannot be determined in this graph. Therefore, the capacity of an edge B i:γ → B j:δ is not important, but it is important to have these edges. Note also that the simplified graph is constructed incrementally for each edge (i, j) ∈ E. Hence, it only requires us to store the Ishikawa edge capacities φ ij corresponding to the edge (i, j). Furthermore, since the simplified graph G s is sparse, an augmenting path can be found fairly quickly.</p><p>In addition, similar to the BK algorithm, we find an augmenting path P s using a Breadth First Search (BFS) scheme and maintain the search tree throughout the algorithm, by repairing it whenever the simplified graph is updated. More specifically, we grow the search tree from the source (node 0), in a breadth first manner, and if the terminal (node 1) is reached, then an augmenting path is found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Augmentation</head><p>Now, given an augmenting path P s in the simplified graph, we want to push the maximum permissible flow through it. More specifically, since P s corresponds to a set of augmenting paths {p s } in the Ishikawa graph, we will push the maximum flow through each path p s , until no such path exists. This could be achieved by constructing the sub-graphĜ p of the Ishikawa graph corresponding to the augmenting path P s , and then finding each of the augmenting path p s by searching inĜ p . This would require us to either storeĜ p (not memory efficient) or call the flow reconstruction algorithm too many times.</p><p>Instead, we propose breaking down the augmentation operation in the simplified graph into a sequence of flow-loops and a subtraction along a column. Then, the maximum flow through the path can be pushed in a greedy manner, by pushing the maximum flow through each flow-loop. Before describing this procedure in detail, we introduce the following definitions.</p><p>Definition 3.4. A flow-loop m(λ, µ, α) in the Ishikawa graph is defined as the following sequence of operations: First, a value α is pushed down the left column from U i:ℓ to U i:λ , then across from U i:λ to U j:µ , and finally up the right column from U j:µ to U j:ℓ . Thus, applying the flow-loop m(λ, µ, α) corresponds to replacing φ by φ + ∆, where</p><formula xml:id="formula_11">∆ i:λ ′ = −α ∀λ ′ ≥ λ , ∆ ij:λµ = −α , ∆ ji:µλ = α , ∆ j:µ ′ = α ∀µ ′ ≥ µ .</formula><p>Definition 3.5. A flow-loopm(γ, δ, α) in the simplified graph G s is defined by the following sequence of operations: First a value α is pushed down the left column from U i:ℓ to B i:γ , then across from B i:γ to B j:δ , and finally up the right column from B j:δ to U j:ℓ .</p><p>Note that, for a flow-loopm(γ, δ, α) to be permissible, block B i:γ must contain node U i:ℓ−1 . Note also that the flow-loopm(γ, δ, α) can be thought of as a summation of flow-loops m(λ, µ, α ′ ), where U i:λ ∈ B i:γ and U j:µ ∈ B j:δ ′ , for all δ ′ ≥ δ (see <ref type="figure" target="#fig_7">Fig. 5</ref>).</p><p>Given these definitions, one can easily see that the augmentation operation along the path P s can be broken down into a sequence of flow-loopsm(γ, δ, α) and a subtraction along the last column k, as illustrated in <ref type="figure" target="#fig_8">Fig. 6</ref>. Now, we push the maximum permissible flow through P s , using the following greedy approach.</p><p>For each edge B i:γ → B j:δ that is part of the path P s , we apply a flow-loopm(γ, δ, α ij ), where α ij is the maximum permissible flow through the edge B i:γ → B j:δ . In fact, applying this flow-loop translates to reconstructing the  Ishikawa edge capacities φ ij corresponding to edge (i, j) and then applying flow-loops m(λ, µ, α ′ ) for all λ ≥λ and µ ≥μ, starting fromλ andμ, until no permissible flowloop m(λ, µ, α ′ ) exists, withλ andμ the smallest values such that U i:λ ∈ B i:γ and U j:µ ∈ B j:δ . Finally, in the last column k, all the values φ k:λ are positive, and the minimum along column k is subtracted from each φ k:λ . It is easy to see that this approach pushes the maximum permissible flow through the path P s .</p><p>Since, for each edge (i, j), we do not store all the 2 ℓ 2 capacities, but only the 2 ℓ exit-flows Σ, augmentation must then also update these values. Fortunately, there is a direct relation between the flow-loops and Σ. To see this, let us consider the example flow-loopm(1, 0, α ij ) shown in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Memory Efficient Max Flow (MEMF)</head><p>Require: φ 0 ⊲ Initial Ishikawa capacities Σ ← 0, T ← ∅ ⊲ Initialize exit-flows and search tree G s ← simplify graph(φ 0 ) ⊲ Initial simplified graph repeat</p><formula xml:id="formula_12">(T, P s ) ← augmenting path(G s , T ) ⊲ Sec. 3.2 Σ ← augment(P s , φ 0 , Σ) ⊲ Sec. 3.3 for each edge (i, j) ∈ E affected by augmentation do φ ij ← compute edges(φ 0 , Σ, i, j) ⊲ Sec. 3.1.1 G ij s ← simplify graph(φ ij , i, j) ⊲ Sec. 3.2 T ← repair tree(T, G s )</formula><p>⊲ Repair search tree until no augmenting paths possible return get labelling(T ) ⊲ Read from search tree Similar updates can be done for all flow-loops in our procedure. Note that the edge B i:γ → B j:δ represents a collection of possible paths from all the nodes U i:λ ∈ B i:γ to all the nodes U j:µ ∈ B j:δ ′ , for all δ ′ ≥ δ. Therefore, unlike in the full Ishikawa graph, after applying a flow-loop, the portion of the graph G ij s corresponding to edge (i, j) ∈ E needs to be reconstructed. This, however, can be done in a memory efficient manner, since it only involves one edge (i, j) at a time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Summary</head><p>Our memory efficient max-flow (MEMF) method is summarized in Algorithm 2. Let us briefly explain the subroutines below.</p><p>simplify graph: Given the initial Ishikawa capacities φ 0 , this subroutine constructs the simplified graph by amalgamating nodes into blocks as described in Section 3.2. If the input to the subroutine is the Ishikawa capacities φ ij corresponding to the edge (i, j) ∈ E, then it constructs the simplified graph portion G ij s . augmenting path: Given the simplified graph G s and the search tree T , this subroutine finds an augmenting path P s by growing the search tree, as discussed in Section 3.2. augment: Given the path P s , this subroutine pushes the maximum permissible flow through it by applying flowloopsm(γ, δ, α) and then subtracting the minimum from the last column, as discussed in Section 3.3.</p><p>compute edges: Given the initial Ishikawa edge capacities φ 0 and the set of exit-flows Σ, this subroutine computes the non-negative residual Ishikawa edge capacities φ ij corresponding to the given edge (i, j). This is accomplished by solving a small max-flow problem (see Section 3.1.1).</p><p>repair tree: This subroutine is similar to the adoption stage of the BK algorithm. Given the reconstructed simplified graph, the search tree T is repaired by checking for valid parents for each orphan node. See Section 3.2.3 in <ref type="bibr" target="#b4">[5]</ref> for more details.</p><p>get labelling: This subroutine directly reads the optimal labelling from the search tree T .</p><p>As discussed above, the exit-flows Σ require O(ℓ) storage for each edge (i, j) ∈ E. In addition, the simplified graph G s can have at most O(|V| ℓ) blocks and O(|E| ℓ) edges. Furthermore, recall that we assume that the initial Ishikawa capacities φ 0 can be stored efficiently. Therefore, ultimately, our algorithm requires O((|V| + |E|) ℓ) values to be stored.</p><p>Note that, even though our algorithm is efficient, similarly to the BK algorithm, it lacks a polynomial time guarantee. In fact, we lose the ability to find the shortest augmenting path in the Ishikawa graph, due to graph simplification. Therefore, it would be interesting to come up with a simplification strategy that can yield a polynomial time bound on our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Related work</head><p>The approaches that have been proposed to minimize multi-label submodular MRFs can be roughly grouped into two categories: Those based on max-flow and those based on an LP relaxation of the problem. Below, we briefly review representative techniques in each category. Max-flow-based methods. The most popular method to minimize a multi-label submodular MRF energy is to construct the Ishikawa graph <ref type="bibr" target="#b12">[13]</ref> and then apply a max-flow algorithm to find the min-cut solution. Broadly speaking, there are three different kinds of max-flow algorithms: those relying on finding augmenting paths <ref type="bibr" target="#b7">[8]</ref>, the pushrelabel approach <ref type="bibr" target="#b11">[12]</ref> and the pseudo-flow techniques <ref type="bibr" target="#b5">[6]</ref>. Even though numerous implementations are available, the BK method <ref type="bibr" target="#b4">[5]</ref> is arguably the fastest implementation for 2D and sparse 3D graphs. Recently, for dense problems, the IBFS algorithm <ref type="bibr" target="#b10">[11]</ref> was shown to outperform the BK method in a number of experiments <ref type="bibr" target="#b27">[28]</ref>. All the abovementioned algorithms, however, require the same order of storage as the Ishikawa graph and hence scale poorly. Two approaches have nonetheless been studied to scale the maxflow algorithms. The first one explicitly relies on the N-D grid structure of the problem at hand <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14]</ref>. The second one makes use of distributed computing <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b28">29]</ref>. Unfortunately, both these approaches require additional resources (disk space or clusters) to run max-flow on an Ishikawa graph. By contrast, our algorithm lets us efficiently minimize the energy of much larger Ishikawa-type graphs on a standard computer. Furthermore, using the method of <ref type="bibr" target="#b23">[24]</ref>, it can also be parallelized. LP relaxation-based methods. One memory-efficient way to minimize a multi-label submodular MRF energy consists of formulating the problem as a linear program and then maximize the dual using message-passing techniques <ref type="bibr" target="#b29">[30]</ref>. Many such algorithms have been studied <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b30">31]</ref>. Even though these algorithms are good at ap- proximating the optimal solution, as evidenced by the comparison of <ref type="bibr" target="#b14">[15]</ref> and by our experiments, they usually take much longer to converge to the optimal solution than maxflow-based techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>We evaluated our algorithm on the problems of stereo correspondence estimation and image inpainting. For stereo correspondence estimation, we employed six instances from the Middlebury dataset <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>: Tsukuba, Venus, Sawtooth, Map, Cones and Teddy, and one instance from the KITTI dataset <ref type="bibr" target="#b8">[9]</ref> (see <ref type="figure" target="#fig_10">Fig. 7</ref>). For Tsukuba and Venus, we used the unary potentials of <ref type="bibr" target="#b24">[25]</ref>, and for all other stereo cases, those of <ref type="bibr" target="#b2">[3]</ref>. For inpainting, we used the Penguin and House images employed in <ref type="bibr" target="#b24">[25]</ref>, and we used the same unary potentials as in <ref type="bibr" target="#b24">[25]</ref>. In all the above cases, we used pairwise potentials that can be expressed as</p><formula xml:id="formula_13">θ ij (x i , x j ) = w ij θ(|x i − x j |) ,<label>(6)</label></formula><p>where, unless stated otherwise, the regularizer θ(|x i − x j |) is the quadratic function. Furthermore, in all our experiments, we employed a 4-connected neighbourhood. We compare our results with two max-flow implementations: the BK method <ref type="bibr" target="#b4">[5]</ref> and Excesses Incremental Breadth First Search (EIBFS) <ref type="bibr" target="#b9">[10]</ref>, and three LP relaxation-based algorithms: Tree Reweighted Message Passing (TRWS) <ref type="bibr" target="#b16">[17]</ref>, Subgradient based Dual Decomposition (DDSG) <ref type="bibr" target="#b17">[18]</ref> and the Adaptive Diminishing Smoothing algorithm (ADSal) <ref type="bibr" target="#b18">[19]</ref>. For DDSG and ADSal, we used the Opengm <ref type="bibr" target="#b1">[2]</ref> implementations. For the other algorithms, we employed the respective authors' implementations.</p><p>In practice, we only ran the BK method and EIBFS if the graph could be stored in RAM. Otherwise, we provide an estimate of their memory requirement. For LP relaxationbased methods, unless they converged, we ran the algorithms either for 10000 iterations, or for 50000 seconds, whichever occurred first. Note that the running times reported for our algorithm include graph construction. All our experiments were conducted on a 3.4 GHz i7-4770 CPU with 16 GB RAM.</p><p>The memory consumption and running times of the algorithms are provided in <ref type="table">Table 1</ref>. Altogether, our algorithm lets us solve much larger problems than the BK method and EIBFS, and is an order of magnitude faster than state-ofthe-art message-passing algorithms. 1986 --&gt;50000 &gt;50000 &gt;50000 9001 <ref type="table">Table 1</ref>: Memory consumption and runtime comparison with state-of-the-art baselines. A "*" indicates a memory estimate, and "&gt;" indicates that the algorithm did not converge to the optimum within the specified time. Note that our algorithm has a memory consumption O(ℓ) times lower than the max-flow-based methods and is an order of magnitude faster than message-passing algorithms. Compared to EIBFS, our algorithm is only 4 -7 times slower, but requires 12 -23 times less memory, which makes it applicable to more realistic problems. In all stereo problems, TRWS cached the pairwise potentials in an array for faster retrieval, but in the case of inpainting, it was not possible due to excessive memory requirement. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">MEMF analysis</head><p>Note that, at each iteration, i.e., at each augmentation step, our algorithm performs more computation than standard max-flow. Therefore, we would like our algorithm to find short augmenting paths and to converge in fewer iterations than standard max-flow. Below, we analyze these two properties empirically.</p><p>In <ref type="figure" target="#fig_11">Fig. 8</ref>, we show the distribution of the lengths of the augmenting paths found by our algorithm for the Tsukuba stereo instance. Note that the median length is only 5. As a matter of fact, the maximum length observed over all our experiments was 1073 for the KITTI data. Nevertheless, even in that image, the median length was only 15. Note that, since our algorithm finds augmenting paths in a simplified graph, the path lengths are not directly comparable to those found by other max-flow-based methods. In terms of number of augmentations, we found that our algorithm only required between 35% and 50% of the total number of augmentations of the BK method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Minimizing non-submodular MRFs</head><p>Since our algorithm can simply replace standard maxflow in Ishikawa-type graphs, we replaced the BK method  <ref type="table">Table 2</ref>: Memory consumption and runtime comparison of IRGC+expansion with either the BK method or our MEMF algorithm as subroutine (IRGC and MIRGC respectively). Here, "Penguin-128/10" corresponds to the Penguin problem with 128 labels and the truncated quadratic function with truncation value 10 as pairwise potential. A "*" indicates a memory estimate. Compared to IRGC, MIRGC is only 4 -11 times slower but requires 13 -18 times less memory, which makes it applicable to much larger MRFs.</p><p>with our MEMF procedure in the IRGC algorithm <ref type="bibr" target="#b0">[1]</ref>, which minimizes MRFs with some non-convex pairwise potentials by iteratively building and solving an Ishikawa graph. This lets us tackle much larger non-submodular problems. In particular, we computed inpainting results on Penguin by using all 256 labels, as opposed to the down-sampled label sets used in <ref type="bibr" target="#b0">[1]</ref>. The results of the IRGC+expansion algorithm, with the BK method (IRGC) and with MEMF (MIRGC) are summarized in <ref type="table">Table 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>We have introduced a variant of the max-flow algorithm that can minimize multi-label submodular MRF energies optimally, while requiring much less storage. Furthermore, our experiments have shown that our algorithm is an order of magnitude faster than state-of-the-art methods. We therefore believe that our algorithm constitutes the method of choice to minimize Ishikwa-type graphs when the complete graph cannot be stored in memory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Example of an Ishikawa graph. The graph incorporate edges with infinite capacity from U i:λ to U i:λ+1 , not shown in the graph. Here the cut corresponds to the labeling x = {1, 2} where the label set L = {0, 1, 2, 3}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Definition 3.2. A flow ψ is called permissible if φ 0ij:λµ − ψ ij:λµ ≥ 0 for all e ij:λµ ∈Ê.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>An example of two equivalent flow representations with the same exit-flows. Note that each red arrow represents the value ψ ij:λµ and the opposite arrows ψ ji:µλ are not shown. Furthermore, the exit-flows Σ are shown next to the nodes and the initial edges φ 0 are not shown. In (c), the flow ψ ′ is obtained from ψ by passing flow around a loop.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Definition 3.3. A flow ψ is called null if the total flow into a node is zero for all nodes including the source and the terminal, i.e., satisfies Eq. 3 for all U i:λ ∈V ∪ {0, 1}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Lemma 3 . 1 .</head><label>31</label><figDesc>Two sets of capacities φ and φ ′ represent the same energy function exactly (not up to a constant), written as</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Given φ 0 and Σ (left), flow reconstruction is formulated as a max-flow problem (right). Here the nodes with positive exit-flows are connected to the source (0) and those with negative exit-flows are connected to the terminal (1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 3 . 2 .</head><label>32</label><figDesc>Given the set of Ishikawa capacities φ, there is an augmenting path in the simplified graph if and only if there exists an augmenting path in the Ishikawa graph. Proof. In supplementary material.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>An example flow-loopm(1, 0, α ij ) in the simplified graph (left) is equivalent to the summation of two flowloops m(3, 1, α 1 ) and m(4, 4, α 2 ) in the Ishikawa graph (right), with α ij = α 1 + α 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>An augmentation operation is broken down into a sequence of flow-loopsm(γ, δ, α), and a subtraction along the column k. The augmenting path P s is highlighted in red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 5 .</head><label>5</label><figDesc>Applying this flow-loop updates the corresponding exit-flows asΣ ij:3 = Σ ij:3 + α 1 ,(5)Σ ji:1 = Σ ji:1 − α 1 , Σ ij:4 = Σ ij:4 + α 2 , Σ ji:4 = Σ ji:4 − α 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Left and right images of the stereo instance from the KITTI dataset. The images are of size 1241 × 376, and we set the number of labels to 40. This image pair was chosen arbitrarily as a representative of the dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Lengths of augmenting paths found by our algorithm for the Tsukuba stereo instance. Each bar indicates the proportion of paths of a certain length. For example, out of all augmenting paths 28% of them were of length 2. The red arrow indicates the median length.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">E + denotes the set of directed edges between the vertices in the MRF, i.e., if (i, j) ∈ E then, (i, j) ∈ E + and (j, i) ∈ E + .</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">A conservative flow is often referred to as a flow in the literature.(a) ψ (b) ψ ′ (c) ψ ≡ ψ ′</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Iteratively reweighted graph cut for multi-label mrfs with non-convex priors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ajanthan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hartley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Salzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Opengm: A c++ library for discrete graphical models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Andres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Beier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Kappes</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1206.0111</idno>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A pixel dissimilarity measure that is insensitive to image sampling. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Birchfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tomasi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="406" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Pseudo-boolean optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Boros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Hammer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">123</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="155" to="225" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Boykov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kolmogorov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A computational study of the pseudoflow and push-relabel algorithms for the maximum flow problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Chandran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Hochbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations research</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="358" to="376" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A scalable graph-cut algorithm for nd grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Delong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Boykov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>CVPR 2008. IEEE Conference on</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Flows in networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Fulkerson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1962" />
			<publisher>Princeton Princeton University Press</publisher>
			<biblScope unit="volume">1962</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Vision meets robotics: The kitti dataset</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Geiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lenz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stiller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Urtasun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The International Journal of Robotics Research</title>
		<imprint>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page">0278364913491297</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Faster and more dynamic maximum flow by incremental breadth-first search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Werneck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithms-ESA 2015</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="619" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Maximum flows by incremental breadth-first search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Werneck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithms-ESA 2011</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="457" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A new approach to the maximum-flow problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="921" to="940" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Exact optimization for markov random fields with convex priors. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ishikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Cache-efficient graph cuts on structured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Jamriška</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sỳkora</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hornung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="3673" to="3680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A comparative study of modern inference techniques for structured discrete energy minimization problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Kappes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Andres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">A</forename><surname>Hamprecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schnörr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nowozin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Batra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">X</forename><surname>Kausler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kröger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lellmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Komodakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Savchynskyy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rother</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Vision</title>
		<imprint>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficiently solving dynamic markov random fields using graph cuts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H</forename><surname>Torr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision, 2005. ICCV 2005. Tenth IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="922" to="929" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Convergent tree-reweighted message passing for energy minimization. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kolmogorov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Mrf energy minimization and beyond via dual decomposition. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Komodakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Paragios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tziritas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="531" to="552" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient mrf energy minimization via adaptive diminishing smoothing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Savchynskyy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Kappes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schnörr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Uncertainty in Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A taxonomy and evaluation of dense two-frame stereo correspondence algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Scharstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International journal of computer vision</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="7" to="42" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">High-accuracy stereo depth maps using structured light</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Scharstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 2003 IEEE Computer Society Conference on</title>
		<meeting>2003 IEEE Computer Society Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">195</biblScope>
		</imprint>
	</monogr>
	<note>Computer Vision and Pattern Recognition</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Transforming an arbitrary minsum problem into a binary one</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Flach</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>TU, Fak. Informatik</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A distributed mincut/maxflow algorithm combining path augmentation and push-relabel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shekhovtsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Hlaváč</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International journal of computer vision</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="342" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Parallel and distributed graph cuts by dual decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Strandmark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition (CVPR), 2010 IEEE Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A comparative study of energy minimization methods for markov random fields with smoothness-based priors. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zabih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Scharstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Veksler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kolmogorov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Agarwala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tappen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rother</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1068" to="1080" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Improved moves for truncated convex models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Torr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="889" to="896" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Multi-label moves for mrfs with truncated convex priors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Veksler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International journal of computer vision</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Maxflow revisited: An empirical comparison of maxflow algorithms for dense vision problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Batra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMVC</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Cuda cuts: Fast graph cuts on the gpu</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vineet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Narayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition Workshops</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>CVPRW&apos;08</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Map estimation via agreement on trees: message-passing and linear programming. Information Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wainwright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Jaakkola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Willsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="3697" to="3717" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A linear programming approach to max-sum problem: A review. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
