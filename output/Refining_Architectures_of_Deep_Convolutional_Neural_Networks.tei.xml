<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /mnt/c/Users/pc/Desktop/cs510_proj/grobid-0.5.6/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Refining Architectures of Deep Convolutional Neural Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sukrit</forename><surname>Shankar</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duncan</forename><surname>Robertson</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research Cambridge</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yani</forename><surname>Ioannou</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Criminisi</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research Cambridge</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Cipolla</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Machine Intelligence Lab</orgName>
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Refining Architectures of Deep Convolutional Neural Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.5.6" ident="GROBID" when="2019-12-02T16:45+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Deep Convolutional Neural Networks (CNNs) have recently evinced immense success for various image recognition tasks <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b27">27]</ref>. However, a question of paramount importance is somewhat unanswered in deep learning research -is the selected CNN optimal for the dataset in terms of accuracy and model size?</p><p>In this paper, we intend to answer this question and introduce a novel strategy that alters the architecture of a given CNN for a specified dataset, to potentially enhance the original accuracy while possibly reducing the model size. We use two operations for architecture refinement, viz. stretching and symmetrical splitting. Stretching increases the number of hidden units (nodes) in a given CNN layer, while a symmetrical split of say K between two layers separates the input and output channels into K equal groups, and connects only the corresponding input-output channel groups. Our procedure starts with a pre-trained CNN for a given dataset, and optimally decides the stretch and split factors across the network to refine the architecture. We empirically demonstrate the necessity of the two operations.</p><p>We evaluate our approach on two natural scenes attributes datasets, SUN Attributes [16]  and , with architectures of  that   are quite contrasting in their construction. We justify our choice of datasets, and show that they are interestingly distinct from each other, and together pose a challenge to our architectural refinement algorithm. Our results substantiate the usefulness of the proposed method.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Deep Convolutional Neural Networks (CNNs) have recently shown immense success for various image recognition tasks, such as object recognition <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b22">22]</ref>, recognition of man-made places <ref type="bibr" target="#b27">[27]</ref>, prediction of natural scenes attributes <ref type="bibr" target="#b20">[20]</ref> and discerning of facial attributes <ref type="bibr" target="#b13">[13]</ref>. Out of the many CNN architectures, AlexNet <ref type="bibr" target="#b11">[11]</ref>, GoogleNet <ref type="bibr" target="#b22">[22]</ref> and VGG <ref type="bibr" target="#b21">[21]</ref> can be considered as the most popu-lar ones, based on their impressive performance across a variety of datasets. While architectures of AlexNet and GoogleNet have been carefully designed for the large-scale ImageNet <ref type="bibr" target="#b4">[4]</ref> dataset, VGG can be seen as being relatively more generic in curation. Irrespective of whether an architecture has been hand-curated for a given dataset or not, all of them show significant redundancy in their parameter space <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b12">12]</ref>, i.e. for a significantly reduced number of parameters (sometimes as high as 90% reduction), a given architecture might achieve nearly the same accuracy as obtained with the entire set of parameters. Researchers have utilized this fact to speed up inference by estimating the set of parameters that can be zeroed out with a minimal loss in original accuracy. This is typically done through sparse optimization techniques <ref type="bibr" target="#b12">[12]</ref> and low-rank procedures <ref type="bibr" target="#b8">[8]</ref>.</p><p>Envisaging a real-world scenario: We try to envisage a real-world scenario. A user has a new sizeable image dataset, which he wants to train with a CNN. He would typically try out famous CNN architectures like AlexNet, GoogleNet, VGG-11, VGG-16, VGG-19 and then select the one which gives maximum accuracy. In case his application prioritizes a reduced model size (number of parameters) as compared to the accuracy (e.g. applications for mobile platforms and embedded systems), he will try to strike a manual trade-off of how much he wants to sacrifice the accuracy for a reduction in model size.</p><p>Once he makes his choice, what if his finally selected architecture could be altered so as to potentially give a better accuracy while also reducing the model size ? In this paper, we aim to target such a scenario. Note that in all cases, the user can further choose to apply one of the sparsification techniques such as <ref type="bibr" target="#b12">[12]</ref> to significantly reduce the model size with a slight decrease in accuracy. We now formally define our problem statement as follows :</p><p>Given a pre-trained CNN for a specific dataset, refine the architecture in order to potentially increase the accuracy while possibly reducing the model size.</p><p>Operations for CNN architecture refinement: One may now ask what is exactly meant by the refinement of a CNN architecture. On a broader level, refining a CNN STRETCH / WIDEN SPLIT SYMMETRIC <ref type="figure">Figure 1</ref>. Operations considered for our approach: We consider two operations, viz. stretch (left) and symmetric split (right), for architectural refinement of a CNN. Stretching refers to increase in number of hidden units (nodes) for a given layer, without changing its connection pattern to the previous or the next layer. A stretch by a factor of 1.5 is shown here. A symmetrical split of say K between two layers separates the input and output channels into K equal groups, and the corresponding input and output channel groups are connected. A symmetric split of 2 is shown here. Symmetrical split is implemented as the group parameter in Caffe <ref type="bibr" target="#b9">[9]</ref>. architecture can involve altering one or more of the following: the number of hidden units (nodes) in any layer, the connection pattern between any two layers, and the depth of the network. On a relatively finer level, one might think of changing the convolution kernel size, pooling strategies and stride values to refine an architecture.</p><p>In this paper, we consider the task of CNN architecture refinement on a broader level. Since we embark on such a problem in this work, we only consider two operations, viz. stretch and symmetric split. Stretching refers to increase in number of hidden units (nodes) for a given layer, while a symmetrical split of say K between two layers separates the input and output channels into K equal groups, and the k th input channel group is only connected to the k th output channel group 1 . Please see <ref type="figure">Fig 1</ref> for an illustration of these operations. We do not consider the other plausible operations for architectural refinement of CNN; for instance, arbitrary connection patterns between two layers (instead of just symmetric splitting), reducing the number of nodes in a layer, and alteration in the depth of the network.</p><p>Intuition behind our approach: The main idea behind our approach is to best separate the classes of a dataset, assuming a constant depth of the network. Our method starts with a pre-trained CNN, and studies separation between classes at each convolutional layer. Based on the nature of the dataset, separation between some classes may be more at lower layers, while for others, may be lesser at lower layers. Similar variations may be seen at deeper layers. In 1 For better understanding, we give an example of symmetric splitting with convolutional layers. Let a convolutional layer conv 1 having 96 outputs be connected to conv 2 having 256 outputs. Then there are 96 × 256 input connections for conv 2 , each connection having a filter of square size <ref type="bibr">(11 × 11 say)</ref>. A splitting of 2 for conv 2 divides input connections of conv 2 into 2 symmetric groups, such that the first / second 48 outputs of conv 1 only get connected to the first / second 128 outputs of conv 2 . comparison to its previous layer, a given layer can increase the class separation for some class pairs, while decreasing for others. The number of class pairs for which the class separation increases contributes to the stretching / widening of the layer; while the number of class pairs where the class separation decreases contributes to the symmetric splitting of the layer inputs. Thus, both stretch and split operations can be simultaneously applied to each layer. The amount of stretch or split is not only decided by how the layer affects the class separation, but also by the class separation capacity of the subsequent layers. Once the stretch and split factors are estimated, they are applied to original CNN for architectural refinement. The refined architecture is then trained again (from scratch) on the same dataset. Section 3 provides complete details of our proposed approach.</p><p>Our contribution(s): Our major contributions can now be summarized as follows :</p><p>1. For a given pre-trained CNN, we introduce the problem of refining network architecture so as to potentially enhance the accuracy while possibly reducing the required number of parameters.</p><p>2. We introduce a strategy that starts with a pre-trained CNN, and uses stretch and symmetric split <ref type="figure">(Fig 1)</ref> operations for CNN architecture refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Deep Convolutional Neural Networks (CNNs) have experienced a recent surge in computer vision research due to their immense success for visual recognition tasks <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b27">27]</ref>. Given a sizeable training set, CNNs have proven to be far more robust as compared to the hand-crafted low-level features like Histogram of Oriented Gradients (HOG) <ref type="bibr" target="#b3">[3]</ref>, color histograms, gist descriptors <ref type="bibr" target="#b14">[14]</ref> and the like. For visual recognition, CNNs provide impressive performance for recognition of objects <ref type="bibr" target="#b22">[22]</ref>, man-made places <ref type="bibr" target="#b27">[27]</ref>, attributes of natural scenes <ref type="bibr" target="#b20">[20]</ref> and facial attributes <ref type="bibr" target="#b13">[13]</ref>. However, learning an optimal CNN architecture for a given dataset is largely an open problem. Moreover, it is less known, how to find if the selected CNN is optimal for the dataset in terms of accuracy and model size or not.</p><p>Transfer learning with deep nets: With the availability of large scale datasets such as ImageNet <ref type="bibr" target="#b4">[4]</ref> and MIT Places <ref type="bibr" target="#b27">[27]</ref>, researchers have resorted to transfer learning techniques <ref type="bibr" target="#b23">[23]</ref> for efficient training of relatively smaller related datasets <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b28">28]</ref>. During transfer learning, the parameters of the CNN trained with base dataset are duplicated, and some additional layers are attached at the deep end of the CNN which are trained exclusively on the new dataset. In the process, the parameters copied from the net trained on the base dataset might or might not be allowed for slight perturbation. However, none of the transfer learning techniques attempts to refine the CNN architecture ef-  <ref type="figure">Figure 2</ref>. Inception Module of GoogleNet <ref type="bibr" target="#b22">[22]</ref> :</p><p>The inception module is an intrinsic component of the GoogleNet architecture. GoogleNet has 9 inception modules named as 3a, 3b, 4a, 4b, 4c, 4d, 4e, 5a, 5b connected one after another. The inception module has two layers and 6 convolutional blocks (green blocks), connected as shown in the figure. As an implementation perspective of our approach with GoogleNet, for a convolutional block l in Layer 1, the subsequent blocks are all convolutional blocks in layer 2, irrespective of the connection pattern. This is done for ease in the computation of (2) and (3). However, for a given convolutional block l in a layer of inception module, its previous convolutional block is considered only to be the one from which l has incoming links. The distinction is made for simplicity in computation, as the statistics of the previous layer is only required in case (b) of our approach (Section 3), for deciding whether any operation should be applied to the current block or not.</p><p>fecting an increase in original accuracy and a reduction in model size simultaneously. While transfer learning can be effective when the base dataset has a similar distribution as the target dataset, it might be a deterrent otherwise <ref type="bibr" target="#b20">[20]</ref>. We emphasize that our approach can be applied to any pretrained CNN, irrespective of whether the training has been done through transfer learning or from scratch.</p><p>Low-rank and sparsification methods for CNNs: Irrespective of whether a CNN has been hand-designed for a specific dataset or not, all the famous CNN architectures exhibit enormous redundancy in parameter space <ref type="bibr" target="#b12">[12]</ref>. Researchers have recently exploited this fact to speed up the inference speeds by estimating a highly reduced set of parameters which is sufficient to produce nearly the same accuracy as the original CNN does with the full set of parameters. While some works like <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b24">24]</ref> have resorted to low-rank factorization of weight matrices between two given layers, others have used sparsification methods for the same <ref type="bibr" target="#b6">[6]</ref>. Recently, <ref type="bibr" target="#b12">[12]</ref> has combined the low-rank and sparsification methods to produce a highly sparse CNN with a slight decrease in the original accuracy. The work of <ref type="bibr" target="#b5">[5]</ref> can be considered as a pseudo-reduction method for the parameter space of a CNN. It does not sparsify the network, but presents an approach to estimate almost 95% of parameters from only the rest 5%. Thus, they do not claim that most parameters are not necessary, but that most parameters can be estimated by a relatively small set.</p><p>It is worthwhile to mention that our approach falls into a different solution paradigm, that can complement various methods developed for deep learning for distinct purposes.</p><p>All the related works discussed above and some other works that tend to enhance the accuracy with deep learning such as <ref type="bibr" target="#b20">[20]</ref> and deep boosting methods <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b19">19]</ref>, assume a fixed architectural model of the CNN. Our approach instead modifies the architecture of the original CNN to potentially enhance the accuracy while possibly reducing the model size. Thus, all the techniques applied to a fixed architecture can be applied to the architecture refined by our method, for a plausibly better performance as per the chosen metric. Also, due to the novel operations that we consider for CNN architectural refinement, our method can complement the various other methods developed for a similar purpose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Approach</head><p>Let the dataset contain M classes. Let the CNN architecture have L convolutional layers. At a given convolutional layer l ∈ {1, . . . , L}, let there be h l number of hidden units (nodes). Then for a given input image i, one can generate an h l dimensional feature vector f i l at convolutional layer l, by taking average spatial responses at each hidden unit of the layer <ref type="bibr" target="#b26">[26]</ref>. Using this, one can find a mean feature vector of dimension h l for every class m ∈ {1, . . . , M } at every convolutional layer l by taking the average of f i l ∀ i ∈ a m , where the set a m contains images annotated with class label m. Let this average feature vector for class m be denoted by g m l . Finding the inter-class separation: For a given dataset and a base CNN architecture, we first train the CNN on the dataset using a given loss function (such as softmax loss, sigmoid cross entropy loss, etc. <ref type="bibr" target="#b9">[9]</ref>). From this pre-trained CNN, we compute g m l ; l ∈ {1, . . . , L}, m ∈ {1, . . . , M }. Using g m l , inter-class correlation matrices C l of sizes M × M are found out for every convolutional layer l, where a value at the index-pair (m,m); m,m ∈ {1, . . . , M } in C l indicates the correlation between g m l and gm l . Note that the correlation between two feature vectors of the same length can vary between -1 and 1, inclusive. Examples of C l can be seen in <ref type="figure" target="#fig_1">Fig 4.</ref> All C l are symmetric, since correlation is non-causal. A lesser correlation between classes implies better separation, and vice-versa.</p><p>Measuring separation enhancement and deterioration capacity of a layer: The correlation matrices give an indication of the separation between classes for a given convolutional layer. Comparing C l and C l+1 , one can know for which class pairs, the separation increased (correlation decreased) in layer l + 1, and for which ones, the separation deteriorated (correlation increased) in l + 1. Similar statistics for layer l can be computed by comparing C l−1 and C l . For a convolutional layer l, let the number of class pairs where the separation increased in comparison to layer l − 1 be n l + , and where the separation decreased be n l − . Let n T = M 2 denote the total number of class pairs. Note that both stretch and split operations can be simultaneously ap-plied to each layer. n l + contributes to the stretching / widening of the layer l, while n l − contributes to the symmetric splitting of its inputs.</p><p>In the domain of decision tree training <ref type="bibr" target="#b2">[2]</ref>, information gain is used to quantify the value a node adds to the classification task. However, in the context of our work, this measure would not enable us to estimate both the split and the stretch factors for the same layer. Thus, we resort to the number of class pairs where the separation increases / decreases to measure the separation enhancement and deterioration capacity of a layer respectively. As we will discuss in the next subsection and Section 4, both the stretch and split operations applied to the same layer helps us to optimally reduce the model size and increase accuracy.</p><p>Estimating stretch and split factors: By the definition of n l + , for a layer l, we define the average class separation enhancement capability of the subsequent layers by the following expression:</p><formula xml:id="formula_0">ξ(l) = L−1 i=l+1 (n i + / n T )/(L − l − 1)<label>(1)</label></formula><p>Note that we omit the last layer L in the above expression. This is discussed at the end of this subsection. For each l, there can be two cases, (a) n l</p><formula xml:id="formula_1">+ &lt; n l − , (b) n l + ≥ n l − . Case (a)</formula><p>implies that the number of class pairs for which separation decreased were more than for which separation increased. This is not a desired scenario, since with subsequent layers, we would want to gradually increase the separation between classes. Thus, in case (a), we do a symmetric split between l − 1 and l, i.e. the connections incoming to l undergo a split. This is done under the hypothesis that split should minimize the hindering linkages and thus cause a lesser deterioration in the separation of class pairs in layer l. The amount of split is decided by n l − and the average separation enhancement potential of the subsequent layers ξ(l). For example, if the subsequent layers greatly increase the separation between classes, a lesser split should suffice since we do not need to improve the separation potential between layers l and l+1 by a major extent. Doing a high amount of split in this case may be counterproductive, since the efficient subsequent layers might not then get sufficiently informative features to proceed with. Based on this hypothesis, we arrive at the following equation indicating the split factor r l s for convolutional layer l under case(a):</p><formula xml:id="formula_2">r l s = 2 ψ n l − n T ξ(l)<label>(2)</label></formula><p>where ψ(x) = ⌊x/λ⌋. λ is a parameter that controls the amount of reduction in model size. Note that the expression is raised to the power of 2 in <ref type="formula" target="#formula_2">(2)</ref>, meaning that we do splits in multiples of 2. This is done to make the implementation coherent for Caffe's <ref type="bibr" target="#b9">[9]</ref> group parameter. The group parameter in Caffe is similar to the symmetric split operation considered here <ref type="figure">(Fig 1)</ref>. Although group parameter can be any integer, it should exactly divide the number of nodes being split. Since, the number of nodes in architecture layers are typically multiples of 2, we raise the expression to the power of 2 in <ref type="bibr" target="#b2">(2)</ref>. For case (a), no stretching is performed, since that might lead to more redundancy.</p><p>For case (b), the number of class pairs experiencing increased separation are greater than those undergoing deterioration. We aim to stretch the layer as well as split its inputs in such a scenario. The stretch factor is based on n l + and the average separation enhancement capability of subsequent layers ξ(l). If ξ(l) is significant, stretching in l is done to a lesser extent indicating that l needs to help but only to a limited extent to avoid overfitting; and viceversa. We thus arrive at the following equation indicating the stretch factor r l e for layer l in case (b):</p><formula xml:id="formula_3">r l e = 1 + φ n l + n T ξ(l)<label>(3)</label></formula><p>where φ(x) = ⌊x/λ⌋ λ is a function that depends on λ. We add 1 in <ref type="formula" target="#formula_3">(3)</ref>, since a stretch factor of say 1.25 indicates that the number of nodes in the respective layer be increased by a quarter. Note that φ(x) = λψ(x). This indicates that for say λ = 0.25, a split factor of 2 might be roughly equivalent to a stretch factor of 1.25 for enhancing the class separation. This is an empirical choice, which helps us to optimally increase the accuracy and reduce the model size. We will delineate the importance of λ in the next subsection.</p><p>In case (b), due to n l − , there is also some redundancy in the connections between l and l − 1. Thus the inputs of layer l also need to be split. The split factor in this case is again decided by <ref type="bibr" target="#b2">(2)</ref>. The operation of splitting along with stretching helps to reduce the model size while also potentially enhancing the accuracy.</p><p>In our approach, we do not consider the refinement of fully connected layers, but only refine the convolutional layers. This is motivated by the fact that in CNNs, convolutional layers are mostly present in high numbers, with fully connected layers being lesser in number. For instance, GoogleNet has only one fully connected layer at the end after 21 convolutional layers. However, since fully connected layers can contain a significant amount of parameters in comparison to convolutional layers (like in AlexNet), considering fully connected layers for architectural refinement can be worth exploring.</p><p>Since for a layer, our method considers the change in class separation compared to the previous layer, no stretching or splitting is done for the first convolutional layer since it is preceded by the input layer. Also, we notice that the final convolutional layer in general, enhances the separation for most classes in comparison to the penultimate convolutional layer. Thus, stretching it mostly amounts to overfitting, and so, we exclude the last convolutional layer from  <ref type="bibr" target="#b20">[20]</ref> and CAMIT-NSAD dataset <ref type="bibr" target="#b20">[20]</ref>. While classes in SAD are purely attributes, classes in CAMIT-NSAD are attribute-noun pairs. all our analysis. By a similar argument, the last inception unit is omitted from our analysis in GoogleNet.</p><p>Once the stretch / split factors are found using a pretrained architecture, the refined architecture is trained from scratch. Thus, we do not share any weights between the original and the refined architecture. The weight initialization in all cases is done according to <ref type="bibr" target="#b7">[7]</ref>.</p><p>On choice of λ and upper bound: The parameter λ controls the amount of reduction in model size. It is meant to be empirically chosen and the functions ψ(.), φ(.) have been formulated so that they satisfy our hypotheses mentioned in the previous subsection while taking into account the possible effect of λ. If λ increases, the stretch factors decrease and the splits are smaller (see φ(.) and ψ(.)). If λ decreases, the split factors can be very high along with decent values for stretch factors. However, due to the difference in φ(.) and ψ(.), the increase in the stretch factor will be limited as compared to the increase in the split factor. This is desired since we do not wish to increase the model size by vast amounts of stretching operations, which may also lead to overfitting. Hence, with increasing λ, the model size tends to increase, and vice-versa. For all our experiments, we set an empirically chosen λ = 0.25.</p><p>A natural question to now ask is that what range of values of λ should one try? The lower bound may be empirically chosen based on the maximum split factor that one wishes to support. However, λ can be upper-bounded by a value λ o above which no split and stretch factor can change. From the definitions of ψ(.) and φ(.), λ o can be easily given as follows:</p><formula xml:id="formula_4">λ o = max n l ′ + n T ξ(l ′ ) , n l ′ − n T ξ(l ′ ) , n l − n T ξ(l)<label>(4)</label></formula><p>where n l ′ + ≥ n l ′ − ∀ l ′ ; n l + &lt; n l − ∀ l. Refining with GoogleNet: Note that GoogleNet contains various inception modules <ref type="figure">(Fig 2)</ref>, each module having two layers with multiple convolutional blocks. While describing our refinement algorithm, wherever we have mentioned the term convolutional layer, in context of GoogleNet, it should be considered as a convolutional block. Please see <ref type="figure">Fig 2 for</ref> a better understanding of how do we decide subsequent and previous layers in GoogleNet for refining. Also see <ref type="figure" target="#fig_3">Fig 6</ref> for the stretch and split factors obtained after architectural refinement of GoogleNet.</p><p>Continuing architectural refinement: Our method refines the architecture of a pre-trained CNN. One can also apply such a procedure to an architecture that has been already refined by our approach. One can stop once no significant difference in the accuracy or model size is noticed for some choices of λ 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Results and Discussion</head><p>Datasets: We evaluate our approach on SUN Attributes Dataset (SAD) <ref type="bibr" target="#b16">[16]</ref> and Cambridge-MIT Natural Scenes Attributes Dataset (CAMIT-NSAD) <ref type="bibr" target="#b20">[20]</ref>. Both the datasets have classes of natural scenes attributes, whose listing can be found in <ref type="figure" target="#fig_0">Fig 3.</ref> The full version of SAD <ref type="bibr" target="#b16">[16]</ref> has 102 classes. However, following <ref type="bibr" target="#b20">[20]</ref>, we discard the classes in the full version of SAD which lie under the paradigm of recognizing activities, poses and colors; and only consider the 42 visual attribute classes, so that the dataset is reasonably homogeneous for our problem. SAD with 42 attributes has 22,084 images for training, 3056 images for validation and 5618 images for testing. Each image in the training set is annotated with only one class label. Each test image has a binary label for each of the 42 attributes, indicating the absence / presence of the respective attribute. In all, the test set contains 53,096 positive labels.</p><p>CAMIT-NSAD <ref type="bibr" target="#b20">[20]</ref> is a natural scenes attributes dataset containing classes as attribute noun pairs, instead of just attributes. CAMIT-NSAD has 22 attributes and contains 46,008 training images, with at least 500 images for each attribute-noun pair. The validation set and the test set contain 2104 and 2967 images respectively. While each training image is annotated with only one class label, the test The classes are separated lesser in lower layers and more prominently in deeper layers. This is mainly because classes in SAD are purely attributes, while classes in CAMIT-NSAD are attribute-noun pairs. Due to this distinction, the two datasets have nearly contrasting characteristics which pose a challenge to the architectural refinement problem. For instance, snow class in SAD can be separated from dirt class mostly by the distinction of white and brown colors; while in CAMIT-NSAD, the class of snowy forests cannot be separated from snowy mountains just by noticing the color difference, since both forests and mountains are snowy. Infact, in this case, the separation is most likely to appear in deeper layers where the distinction is also made between forests and mountains. The above explanation is made under the widely accepted notion that a CNN learns low-level type features (edges, color patterns, etc.) in lower layers, and more class-specific features in deeper layers <ref type="bibr" target="#b25">[25]</ref>. Also note that some classes in the datasets have a natural correlation, e.g. classes of vegetation, shrubbery, foliage and leaves in SAD are well correlated, since the presence of leaves is very likely where some vegetation occurs. As a result, separation between these classes may always be low as compared to separation between the classes of vegetation and running water. A similar analysis can be made for CAMIT-NSAD. <ref type="figure">Figure is best viewed in color.</ref> images contain binary labels for each of the 22 attributes. In all, the test set contains 8517 positive labels. All images in SAD and CAMIT-NSAD are 256 × 256 RGB.</p><p>It can be seen that classes in SAD are pure attributes, while that in CAMIT-NSAD are noun-attribute pairs. Due to this distinction, the two datasets have different characteristics which make them challenging for the problem of architectural refinement. Please see <ref type="figure" target="#fig_1">Fig 4</ref> for a better understanding of this distinction.</p><p>Notice that classes in CAMIT-NSAD can be finally separated to a greater extent as compared to classes in SAD. This is because almost each class in SAD has a variety of outdoor and indoor scenes, since an attribute can exist for both. For instance, both an outdoor and indoor scene can be glossy as well as can have direct sunlight. However, with nounattribute pairing as in CAMIT-NSAD, the classes are more specifically defined, and thus significant separation between a greater number of class pairs is achieved at the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choice of Datasets:</head><p>The choice of the datasets used for evaluation needs a special mention. We chose attribute datasets, since given the type of labels here, it is difficult to establish where should the model parameters be reduced / increased. This we found was in contrast to object recognition datasets such as ImageNe, where we observed that refining an architecture by symmetric splitting in the first few layers could increase accuracy. However, we thought this to be very intuitive, since objects are generally encoded in deeper layers, and thus, one would expect to reduce pa-rameters in the top layers. We thus evaluate our procedure with the types of datasets, where one cannot easily decide which network layers contribute to the class labels.</p><p>Architectures for Refinement: We choose GoogleNet <ref type="bibr" target="#b22">[22]</ref> and VGG-11 <ref type="bibr" target="#b21">[21]</ref> as the base CNN architectures, which we intend to alter using our approach. Since GoogleNet and VGG-11 are quite contrasting in their construction, they together pose a considerable challenge to our architectural refinement algorithm. While VGG-11 (which can be loosely considered as a deeper form of AlexNet <ref type="bibr" target="#b11">[11]</ref>) has 8 convolutional layers, and 3 fully connected layers, GoogleNet is a 22-layer deep net having 9 inception units after three convolutional layers, and a fully connected layer before the final output. Each inception unit has 6 convolutional blocks arranged in 2 layers. We refer the reader to <ref type="bibr" target="#b22">[22]</ref> and <ref type="bibr" target="#b21">[21]</ref> for complete details of GoogleNet and VGG-11 respectively. An instance of inception module in GoogleNet is shown in <ref type="figure">Fig 2.</ref> Baselines: We consider the following baselines to compare with our proposed approach. (a) Our approach with only stretching and no splitting -We consider refinement with only the stretching operation and no splitting operation, i.e. the CNN architecture is refined by only stretching some layers, but no symmetric splitting between layers is done. This proves the importance of stretching operation for architectural refinement. (b) Our approach with only splitting and no stretching -Evaluating by only considering the symmetrical split operation and no stretch operation   <ref type="bibr" target="#b12">[12]</ref>. We use precision@k as our performance metric, and report that here as a percentage. For SAD, k = 21, while for CAMIT-NSAD, k = 7. Please refer text for details on this. We report the reduction percentage in the parameters of the convolutional layers in comparison to the original architecture. Thus, reporting reduction in model size for Orig is not applicable. Also, since DR-1 only does a stretching operation over the original architecture, it is bound to increase the model size, and thus % reductions in the model size are not applicable here as well. Note that DR performs significantly well for SAD giving a decent reduction in model size with impressive increase in precision. For CAMIT-NSAD, DR does not improve the precision of the original architecture. The results here are reported for λ = 0.25. For CAMIT-NSAD, we also did experiments for higher values of λ but we did not see any increase in precision; rather with increased λ, we got lesser reduction in model size as expected (Section 3) . Nevertheless, for CAMIT-NSAD, DR and DR-2 could produce architectures with a reduced model size producing precision better than the state-of-the-art sparsification techniques of Sp-1 and Sp-2. indicates that a is the stretch factor for the convolutional layer/block, while b is the split factor for the input of that convolutional layer / block. Entry of <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b1">1)</ref> implies no stretch and splitting should be done. In <ref type="figure" target="#fig_2">Fig 5,</ref> for DR-1 , every value of b is made 1, while for DR-2 , every value of a is made 1. VGG-11 contains 8 convolutional layers, for which the factors are shown. In Googlenet, the factors for first three convolutional layers are shown in the first row (under GoogleNet). After that , each row under GoogleNet contains the factors of the convolutional blocks in the inception unit of <ref type="figure">Fig 2.</ref> Traversed row-wise, inception units correspond to the ordering 3a, 3b, 4a, 4b, 4c, 4d, 4e, 5a, 5b of GoogleNet architecture <ref type="bibr" target="#b22">[22]</ref>. Note that since we do not consider the last convolutional layer (that is connected to the fully connected layer) in our analysis, all factors for that are 1 in VGG-11. A similar argument exists for the last inception unit in GoogleNet.</p><p>provides evidence to the utility of splitting. (c) L1 Sparsification -We consider the L1 sparsification of a CNN as one of the important baselines. Here, the weights (parameters) of a CNN are regularized with an L1 norm, and the regularization term is added to the loss function. Due to the L1 norm, this results in a sparse CNN, i.e. a CNN with a reduced model size. Following <ref type="bibr" target="#b12">[12]</ref>, all the parameters with values less than or equal to 1e-4 are made zero both during training and testing. This not only ensures maximal sparsity, but also stabilizes the training procedure resulting in better convergence. (d) Sparsification with the method of <ref type="bibr" target="#b12">[12]</ref> -The method of <ref type="bibr" target="#b12">[12]</ref> combines the low-rank decomposition <ref type="bibr" target="#b8">[8]</ref> and L1 sparsification techniques for better sparsity. However, they mention that the critical step in achieving comparable accuracy with high amount of sparsity, is minimizing the loss function along with L1 and L2 regularization terms upon the weights of the CNN. Lowrank decomposition can increase sparsity with a further decrease in accuracy. Since, in this work, we are interested in an optimal trade-off between accuracy and model size, we evaluate the method of <ref type="bibr" target="#b12">[12]</ref> without the low-rank decomposition. This ensures that we obtain maximum possible accuracy with <ref type="bibr" target="#b12">[12]</ref> at the expense of some reduced sparsity.</p><p>(e) Original architecture: We consider the original architecture without any architectural refinement and sparsification techniques applied. The amount of reduction achieved in the model size with our approach and other baselines along with the recognition performance is compared with this baseline. Note that for all the above mentioned baselines, the CNN is first trained on the respective dataset with the standard minimization of softmax loss function <ref type="bibr" target="#b9">[9]</ref>, after which a second training step is done. For baselines (a) and (b), the re-training step is performed on the refined architecture as described in Section 3; while for baselines (c) and (d), retraining is done as a fine-tuning step, where the learning rate of the output layer is increased to 5 times the learning rate of all other layers.</p><p>Other plausible baselines: We also tried randomly splitting and stretching throughout the network as a plausible baseline. Here although in some cases, we could reduce the model size by almost similar amounts as our proposed approach, significantly higher accuracy was consistently achieved using our method.</p><p>Training: For all datasets and CNN architectures, the networks are trained using the Caffe library <ref type="bibr" target="#b9">[9]</ref>. The pretraining step is always performed with the standard softmax loss function <ref type="bibr" target="#b9">[9]</ref>. For all the pre-training, refinement and baseline cases, batch size of 32 samples is considered. An adaptive step policy is followed during training, i.e. if the change in validation accuracy over a range of 5 consecutive epochs is less than 0.5, the learning rate is reduced by a factor of 10. For SAD, we start with an initial learning rate of 0.01 for both GoogleNet and VGG-11, while for CAMIT-NSAD, a starting learning rate of 0.001 suffices for both the architectures. In all cases, we train for 100 epochs.</p><p>Testing: Given a trained CNN, we need to predict multiple labels for each test image in SAD and CAMIT-NSAD. We use precision@k as our performance metric. The metric is normally chosen when one needs to predict top-k labels for a test image. Since, our ground-truth annotations contain only binary labels for each class, for a given test image, we cannot sort the labels according to their degree of presence. We thus decide k for each dataset as the maximum number of positive labels present for any image in the test set. For SAD, k is 21, while for CAMIT-NSAD, k is 7. Thus, given a test image, we predict the output probabilities of each class using the trained net, and sort these probabilities in the descending order to produce a vector T . If that test image has say 5 positive labels in ground-truth annotations, we expect the first 5 entries of T to correspond to the same labels for a 100% precision. We thus compute the true positives and false positives over the entire test set and report the final precision. This is in line with the test procedure followed by <ref type="bibr" target="#b20">[20]</ref>. <ref type="figure" target="#fig_2">Fig 5</ref> shows the precision and model size reduction results obtained with our approach and the baselines, for both the datasets and both the architectures. For understanding intrinsic details of the refined architectures, please refer to <ref type="figure" target="#fig_3">Fig 6 and Fig 2.</ref> It is clear that for SAD, our approach for both VGG-11 and GoogleNet, offers an increase in original precision while giving a reasonable reduction in model size. The reduction in the number of parameters in convolutional layers holds more importance here, since our method was only applied to the convolutional layers. It is interesting to note from the results on SAD, that the predicted combination of stretch and split is more optimal as compared to only having the split or the stretch operation. This also shows that stretching alone is not always bound to enhance the precision, since it may lead to overfitting. In all cases, the sparsification baselines fall behind the precision obtained with our approach, although they produce more sparsity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discussion of results:</head><p>The results on CAMIT-NSAD present a different scenario. Note that our approach is not able to enhance the precision in this case, but decreases the precision by a small amount, while giving decent reduction in model size. However, the precision obtained with a reduced model size by using our approach is still greater than the one obtained by other baseline sparsification methods, though at the expense of lesser sparsity. The inability to increase precision in this case can be attributed to the fact that our approach is greedy, i.e. it estimates the stretch and split factors for every layer, and not jointly for all layers. This affects CAMIT-NSAD since the classes are attribute-noun pairs, and attribute-specific information and noun-specific information are encoded at different layers, which need to be considered together for refinement.</p><p>Note that a single metric jointly quantifying both the accuracy increase and the model size reduction is difficult to formulate. In cases where we increase the accuracy as well as decrease the model size (SAD), we offer a win-win situation. However, in cases where we decrease the model size but cannot increase the accuracy (CAMIT-NSAD), we believe that the model choice depends on user's requirements, and our method provides an additional and plausibly a useful alternative for the user, and can also complement the other approaches. One can obtain an architecture using our approach, and then apply a sparsification technique like <ref type="bibr" target="#b12">[12]</ref> in case the user's application demands maximum sparsity, and not that good a precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>We have introduced a novel strategy that alters the architecture of a given CNN for a specified dataset for effecting a possible increase in original accuracy and reduction of parameters. Evaluation on two challenging datasets shows its utility over relevant baselines.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 .</head><label>3</label><figDesc>Datasets and Classes: The figure shows the classes present in the SUN Attributes Dataset (SAD) as considered in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Correlation Matrices for 8 Convolutional Layers of VGG-11 trained on SAD and CAMIT-NSAD : Traversed row-wise, correlation matrices C l : l ∈ {1, . . . , 8} are shown. Dark Blue color indicates minimum correlation between classes, while a bright yellow color indicates maximum correlation. Thus, all diagonals are bright yellow, since each class is maximally correlated with itself. For each matrix, the attribute classes are ordered as in Fig 3 seen left to right. Note that more correlation implies lesser separation and vice-versa. Top Row (SAD) : The lower layers can separate the classes better as compared to deeper layers. Bottom Row (CAMIT-NSAD):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 .</head><label>5</label><figDesc>Results and Comparisons : The figure shows results on SAD and CAMIT-NSAD with VGG-11 and GoogleNet using our approach and various other baselines. Orig = Original architecture, DR = Deep Refined Architecture (our approach), DR-1 = Deep Refined Architecture with only the Stretch Operation, DR-2 = Deep Refined Architecture with only the Symmetric Split Operation, Sp-1 = L1 Sparsified network, Sp-2 -Sparsified network with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Refined Architectures obtained with our approach: Left column shows the refined architectures for SAD, and the right column for CAMIT-NSAD. The corresponding precision results are reported in Fig 5 under the column DR. Each tuple (a, b)</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">Although our approach does not induce a concrete optimization objective from the correlation analysis, we believe that it is a step towards solving the deep architecture learning problem, and furthers the related works towards more principled directions. The intuition behind our method was established from various experiments, done on diverse datasets with a variety of shallow and deep CNNs.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">1,2) -(1,4) -(1,1) (1.25,1) -(1.25,2) -(1,2) (1,2) -(1,2) -(1.25,1) (1,1) -(1,2) -(1,2) (1,2) -(1,1) -(1,2) (1,2) -(1.25,2) -(1,4) (1,1) -(1,1) -(1.25,2) (1.25,1) -(1.25,1) -(1.25,2) (1,2) -(1.25,2) -(1,2) First Three Conv Layers -(1.5,1) -(1.5,1) -(1.25,1) (1.25,1) -(1.25,1) -(1,1) (1,1) -(1,1) -(1,1) (1,1) -(1,1) -(1,1) (1,1) -(1,1)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
		</imprint>
	</monogr>
	<note>1,1) -(1,1) -(1,1) (1,1) -(1,1) -(1,1) (1,2) -(1,2) -(1,1) (1,2) -(1,2) -(1,1) (1,1) -(1.. 1,1) (1,1) -(1,1) -(1,1) (1,2) -(1,2) -(1,1) (1,4) -(1,2) -(1,1) (1,4) -(1,2) -(1,2) (1,4) -(1,2) -(1,1) (1,4) -(1,2) -(1,1) (1,2) -(1,4) -(1,1) (1,4) -(1,1) -(1,1) (1,4) -(1,2) -(1,1) (1,4) -(1,2) -(1,2) (1,4) -(1,4) -(1,1) (1,4) -(1,4) -(1,1) (1,1) -(1,1) -(1,1) (1,1) -(1,1) -(1,1) (1,1) -(1,1) -(1,1) (1,1) -(1,1) -(1,1</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Deep boosting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mohri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Syed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Machine Learning (ICML-14)</title>
		<meeting>the 31st International Conference on Machine Learning (ICML-14)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1179" to="1187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Decision forests: A unified framework for classification, regression, density estimation, manifold learning and semi-supervised learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Criminisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shotton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Konukoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Now</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Histograms of oriented gradients for human detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Dalal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Triggs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition, 2005. CVPR 2005. IEEE Computer Society Conference on</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="886" to="893" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Imagenet: A large-scale hierarchical image database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="248" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Predicting parameters in deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shakibi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="2148" to="2156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Graham</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.6070</idno>
		<title level="m">Spatially-sparse convolutional neural networks</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Delving deep into rectifiers: Surpassing human-level performance on imagenet classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Computer Vision</title>
		<meeting>the IEEE International Conference on Computer Vision</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1026" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1405.3866</idno>
		<title level="m">Speeding up convolutional neural networks with low rank expansions</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.5093</idno>
		<title level="m">Caffe: Convolutional architecture for fast feature embedding</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sparse convolutional neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Foroosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tappen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="806" to="814" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1411.7766</idno>
		<title level="m">Deep learning face attributes in the wild</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>To apeear in ICCV</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Building the gist of a scene: The role of global image features in recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Oliva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Torralba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Progress in brain research</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Learning and transferring mid-level image representations using convolutional neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Oquab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Laptev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sivic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1717" to="1724" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sun attribute database: Discovering, annotating, and recognizing scene attributes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hays</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deep boosting: Layered feature mining for general image classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multimedia and Expo (ICME)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Low-rank matrix factorization for deep neural network training with high-dimensional output targets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">N</forename><surname>Sainath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kingsbury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Arisoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ramabhadran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acoustics, Speech and Signal Processing (ICASSP), 2013 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="6655" to="6659" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shalev-Shwartz</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1411.3436</idno>
		<title level="m">Selfieboost: A boosting algorithm for deep learning</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Deep-carving: Discovering visual attributes by carving deep neural nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">K</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cipolla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.1556</idno>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Anguelov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabinovich</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.4842</idno>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Going deeper with convolutions. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Transfer learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Torrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shavlik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Research on Machine Learning Applications and Trends: Algorithms, Methods, and Techniques</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">242</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Restructuring of deep neural network acoustic models with singular value decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INTERSPEECH</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="2365" to="2369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">How transferable are features in deep neural networks?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yosinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lipson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="3320" to="3328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Object detectors emerge in deep scene cnns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lapedriza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Oliva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Torralba</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6856</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Learning deep features for scene recognition using places database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lapedriza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Torralba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Oliva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="487" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Hybrid heterogeneous transfer learning through deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">W</forename><surname>Tsang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Eighth AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
